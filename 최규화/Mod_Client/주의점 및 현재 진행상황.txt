1. 현재 프레임워크 1. 9ver으로 서버연동 작업을 하고 있습니다.

2018. 03. 13 
- 서버에서 초기화 정보를 클라이언트로 보낼 수 있습니다.
- boost asio에 대해서 아직 자세히 모르는 것 같아서 책 읽으면서 작업하고 있습니다. ㅠㅠ

2018. 03. 14
- 클라이언트를 2개 이상 작동시킬 때, 즉 여러명의 클라이언트가 접속했을 때 서버로 부터 받는 정보를 
  클라이언트에서도 관리할 수 있도록 클라이언트 부분을 수정중입니다.
- 클라이언트에서 키 조작을 통해 수정된 위치정보를 서버로 보내는 작업을 하고 있습니다.
- 서버에서 수정된 위치정보를 다시 클라이언트로 보내는 작업을 하고 있습니다.


2018. 03. 15
- 여러명의 플레이어 정보를 클라이언트에서 관리하도록 클라이언트 프로젝트 수정 및 버그 픽스


2018. 03. 20
- 초기화 정보를 서버로 부터 얻어와서 클라이언트에서 플레이어 1 세팅
- 클라이언트에서 키 조작을 통해 이동된 플레이어 데이터를 서버로 보내줌
  이를 서버가 다시 클라이언트로 보내주는 과정에서 생기는 버그 수정중
- async_write_some / async_read_some 을 async_write 와 async_read로 바꾸었음
- 프로토콜 헤더파일에서 패킷 구조체 변경 


2018. 03. 27 ~ 2018. 03. 28
- async_read에 문제가 있어서 async_read_some으로 다시 입출력함수를 바꿈
- 클라이언트에서 키조작을 통해 변화된 값을 서버가 받아 클라이언트에게 다시 해당값을 보내주는 것을 확인
- 서버에서 기존에 Accept 내부에 있던 worker_thread를 외부로빼서 Accept 함수와 worker_thread함수가
  독립적으로 멀티스레드로 작동되게끔 서버 구조를 바꾸어야할것같음. 

2018. 03. 29
- 클라이언트에서 키조작을 통해서 서버에 보내주는 패킷을 처리하는 부분
  (ProcessPacket의 STC_ChangedPos 패킷 처리부분 수정)

2018. 04. 01 ~ 2018. 04. 02
- 2명이상의 클라이언트 접속에 대한 처리 작업 중
[1]. 2명이상의 클라이언트가 접속 후 이동이 잘 되는가
[2]. 2명이상의 클라이언트 중 하나의 클라이언트가 접속을 끊으면 다른 클라이언트에 해당 캐릭터가 보이지 않는가

- 캐릭터의 애니메이션에 대한 처리 작업 중

2018. 04. 03
[한 것]
- 2명의 클라이언트가 접속하여 서버에서 보낸 초기위치에 놓여짐
- 각각의 클라이언트에서 키조작을 통해 이동할 수 있음
- 각각의 클라이언트에서 서로 이동하는 모습이 보임

[해야할 것]
1. 클라이언트에서 접속을 끊을 시에 대한 서버에서의 처리는 되었지만, 클라이언트에서 적용을 아직못했음
2. 1번이 완료되면 기존의 구버전 클라이언트와 연동되던 서버를 새로운 버전 클라이언트와 연동되도록작업을 할 예정
3. 이동 시 캐릭터 애니메이션 추가 및 공격에 대한 처리를 해야됨 

2018. 04. 06 ~ 2018. 04. 07
1. 구버전 클라이언트 1.9 ver에서 프레임워크 2.5ver 으로 서버연동 클라이언트 교체
2. 캐릭터 이동에 대한 서버연동이 되지 않던 문제점을 수정
3. 캐릭터 이동 시 애니메이션 (정지, 달리기 ) 추가
4. 캐릭터 회전정보 추가 
5. 기타 패킷 구조체 추가 및 클라이언트, 서버 코드 수정 
6. 기타 발생한 버그들 수정

2018. 04. 10
1. 서버에 물리효과 및 충돌처리를 구현한 코드 이식
2. 서버에서 물리효과 및 충돌처리를 하기위해 필요한 코드작성
   (lookvector, rightvector, offlookvector, offrightvector, upvector . . .)
3. 충돌처리를 위한 프로토콜에서의 패킷 추가 및 processpacket 함수 업데이트

2018. 04. 11
1. 서버에서 staticobject (box, map)에 대한 데이터를 보내주기 위한 작업진행 중
2. 클라이언트에서 staticobject에 대한 데이터를 받아 처리하기 위한 작업은 끝났음
3. 서버에서 player와 staticobject간의 충돌처리에 대한 작업진행 중

* 클라이언트에서 이동 및 회전을 할 때 packet을 프레임마다 보내는 것이 아님 -> 수정필요

2018. 04. 12
1. 서버에서 staticobject (상자) 데이터를 클라이언트로 보내주는 작업진행 중
  - async_write부분에서 패킷이 제대로 안보내지는 버그발생해서 교수님께 여쭤보고 계속 고치는 중
  - staticobject 용 패킷구조체 따로 구현 및 추가 클래스 구현



2018. 04. 20
1. 충돌처리 구현 중 
  - 플레이어와 스테틱 오브젝트간 충돌
  - 플레이어와 플레이어 간 충돌
  - 플레이어와 불렛간의 충돌 
 
2. 물리효과를 담은 클래스 구현
  - 물리효과를 필요로하는 여러 곳에서 공통적으로 사용될 수 있도록 구현

3. timer_queue 구현 중
  - 각종 이벤트 ( ai, 시간에 따른 변화 등 ) 를 처리해주는 클래스
  
4. timer_queue 와 충돌처리를 해주는 부분과 패킷처리해주는 worker_thread 간의 동기화 작업중
  - mutex lock, unlock 을 사용해서 작업 중

2018. 05. 01
1. 서버의 Timer_Queue 작업 중

2. 충돌처리 작업 중 

2018. 05. 03
1. bullet 정보를 클라이언트로 주기적으로 보내는 작업 중
* 패킷을 전송하는 부분과 클라이언트를 관리하는 부분을 담당하는 Player_Session 클래스와
  주기적인 패킷 혹은 이벤트를 처리해야되는 클래스인 TimerWorker 클래스간의 연동을 시도.
  -> 원래는 bullet 정보를 클라이언트로 주기적으로 보내는 작업을 Player_Session 내부에서 
  하려 했으나 예상했던 방식으로 작동되지 않음. 그래서 위에서 언급한 방식으로, 클래스간 
  연동을 통해서 TimerWorker 클래스에서 작업처리를 하려함.
 
  - 또 문제발생. 1. TimerWorker 스레드는 Player_Session 처럼 많은 스레드를 할당받은게아니라 
                 callback함수들은 되도록 여기서 처리하면 안됨. but, sendpacket은 callback함수.
               2. 1초에 20번씩 sendpacket을함. 불렛리스트와 플레이어리스트를 모두 돌아야함 
                 시간복잡도 0(n2). 성능상에 큰 문제가 생김. 
               3. 위 단점을 극복하고 처리를 하려면 주기적 패킷을 처리하는 작업을 다른 스레드를 
                 또 할당해서 처리해야함. 이렇게 해야하는가? 아닐듯 . . . 좀 더 고민해봐야함 

2018. 05. 04
1. bullet 에 대한 이동 관련
- 서버: 일단 데모에 시연할 캐릭터 수가 많지않으므로 시간복잡도가 큰 편이여도
         TimerWorker 클래스를 통해서 주기적으로 클라이언트로 SendPacket해주는 방식을 선택 
         
- 클라이언트: A 클라이언트가 공격을 눌렀을 때 A 클라이언트는 불렛객체가 생성되지만, 다른 클라이언트는
             A 클라이언트에서 서버로 보낸 불렛객체에 대한 정보를 다시 받아서 클라이언트에서 따로 
             생성을 해야한다. 
             [1]. A 클라이언트에서 공격 -> 서버로 불렛 데이터 전송 -> 서버에서 B클라이언트로 해당 불렛 데이터 송신 
               -> B 클라이언트에서 해당 정보를 가지고 불렛 객체 생성
             = 이 때, 기존의 CreateBullet 함수로는 불렛 생성불가(GameObject 클래스자체를 서버와 클라가 송수신할 수 없으므로)
                별도의 CreateOtherClientBullet 함수 생성. 이를 이용. 여기에 문제가 있을 듯. 일단은 작성함
          
              * 또한, 클라이언트에서 불렛 아이디 관리. 불렛 삭제시 해당 아이디 삭제. 새로운 불렛 생성 시
                삭제 된, 즉 가장 앞 순서에 있는 아이디를 넣어야함. -> 리스트를 이용해서 아이디 관리 

             [2]. [1]과정을 거친 불렛은 A와 B가 모두 불렛 데이터를 갖고 있기 때문에  주기적으로 서버에서 받은
                 데이터를 이용해 위치를 업데이트 시켜줌 

2. 충돌 처리 관련
- 서버: 충돌 처리를 해주는 클래스 생성, 이를 호출하는 스레드 할당. 
        일단, 스테틱 오브젝트와 플레이어. 플레이어와 플레이어간 충돌처리 작업중

- 클라이언트: 서버에서 충돌처리는 계속해주고 이 정보는 1초에 20번의 패킷을 통해 클라이언트로 보내주므로 
             크게 따로 처리해야될 부분이 있다고는 생각이 안드나, 고민해 봐야됨.	  

3. 새로운 클라이언트와 서버 연동
- 아직 진행 안한 상태임. 

2018. 05. 05 ~ 2018. 05. 07
1. Bullet 관련 수정
- 초기생성을 제외한 모든 bullet에 대한 작업을 서버에서 처리하도록 수정
- 서버에서 보낸 bullet 위치와 플레이어에게 보여지는 bullet의 위치가 달랐었고
  클라이언트에서 사라지는 bullet의 위치가 서버와 달랐었는데, 이 부분을 수정.
  즉, 클라이언트와 서버간의 bullet delay를 없앰 

- 클라이언트에서 GetFocus 함수 추가에 따른 bullet 생성 버그가 있었고 이를 수정
  (기존에 GeteFocus함수를 사용하지 않았을 때에는 동시키입력 때문에 하나의 클라이언트가 키를 
   눌러도 다른 클라이언트에서 bullet이 생성됐었음(따로 서버에서 정보를 받지 않아도)
   그렇기 때문에 서버에서 주기적으로 bullet이 이동한 값만 받아도 정상적으로 2개의 클라이언트에
   이동하는 bullet이 표시됐었음)

- Release 모드에서 Bullet이 이동할 때 프로그램이 터지는 현상은 아직 해결하지 못함.
  Debug 모드에서는 Bullet이 잘 이동됨.

2018. 05. 07 ~ 2018. 05. 08
1. Bullet 관련 수정
- Release 모드에서 Bullet이 이동할 때 프로그램이 터지는 현상
   -> 1. Release 모드에서는 Debug 모드와는 다르게 구조체나 new 로 할당된 객체가 생성될 때
         초기화가 자동으로 되지않음. 즉, 데이터의 초기화가 제대로 안되서 발생하는 현상일 가능성이 높음
      2. 멀티스레드를 사용해서 그런 현상이 발생하는 것일수도 있음

2. Collision 작업중
- Bullet과 Player간의 충돌 처리중
  -> Player가 Bullet을 맞았을 때 hp가 한번만 깍이는것이 아니라 연속적으로 감소되는 현상 발생
  -> Bullet이 생명주기를 다했을 때와 캐릭터에 충돌했을 때의 순간이 겹쳐 
     이미 사라진 bullet 데이터를 접근하는 경우 발생 
  위 모두 동기화를 제대로 안해줘서 발생한것 같음. 현재 작업 중 
