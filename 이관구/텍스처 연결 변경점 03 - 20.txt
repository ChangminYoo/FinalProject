기존 텍스처의 문제가 뭐였냐면, 생각해보니까 텍스처를 다시 연결할때 기존의 텍스처의 리소스 상태를 픽셀쉐이더에서 안쓸거라고 설정을
해줬어야 하는것을 안해줬었다. 그래서 자꾸 기존의 텍스처와 현재의 텍스처가 번갈아가거나 또는 섞여서 자질구레한 모자이크현상이 일어났다.
이를 해결하기위해 다음과 같이 셋 텍스처를 변경했다.
현재 텍스처는 하나만 있지만 나중에 다수의 텍스처를 쓰려면 언오더드셋에서 해당 이름으로 텍스처를 찾도록 해야할 것이다.





void SetTexture(ID3D12GraphicsCommandList * commandlist, ComPtr<ID3D12DescriptorHeap>& SrvDescriptorHeap, ID3D12Resource* texture, bool isCubeMap)
{
	static ID3D12Resource* OldResource = NULL;

	if (OldResource == NULL)
		OldResource = texture;
	else
	{
		commandlist->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(OldResource,
			D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE));
	}

	//텍스처는 테이블을 쓸것이므로 힙과 테이블 두개를 연결해야함.
	ID3D12DescriptorHeap* descriptorHeaps[] = { SrvDescriptorHeap.Get() };
	commandlist->SetDescriptorHeaps(_countof(descriptorHeaps), descriptorHeaps);

	CD3DX12_GPU_DESCRIPTOR_HANDLE tex(SrvDescriptorHeap->GetGPUDescriptorHandleForHeapStart());
	tex.Offset(0, CbvSrvDescriptorSize);

	
	if(isCubeMap)
		commandlist->SetGraphicsRootDescriptorTable(0, tex);
	else
		commandlist->SetGraphicsRootDescriptorTable(1, tex);

	commandlist->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(texture,
		 D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE));
}


void SetTexture(ID3D12GraphicsCommandList * commandlist, ComPtr<ID3D12DescriptorHeap>& SrvDescriptorHeap, ID3D12Resource* texture, bool isCubeMap)

SetTexture(commandlist, SrvDescriptorHeap, (*Textures.begin()).second.get()->Resource.Get(),false);